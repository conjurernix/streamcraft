(ns streamcraft.http-defaults.core
  (:require [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [contrib.assert :refer [check]]
            [hyperfiddle.electric :as e]
            [hyperfiddle.electric-ring-adapter :as electric-ring]
            [reitit.openapi :as openapi]
            [reitit.ring :as ring]
            [reitit.ring.coercion :as rrc]
            [reitit.ring.middleware.exception :as exception]
            [reitit.ring.middleware.multipart :as multipart]
            [reitit.ring.middleware.muuntaja :as muuntaja]
            [reitit.ring.middleware.parameters :as parameters]
            [reitit.swagger :as swagger]
            [reitit.swagger-ui :as swagger-ui]
            [ring.middleware.content-type :refer [wrap-content-type]]
            [ring.middleware.cookies :as cookies]
            [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.resource :refer [wrap-resource]]
            [ring.util.http-response :as http]
            [ring.util.response :as res]))

(def default-middleware
  [;; swagger & openapi
   swagger/swagger-feature
   openapi/openapi-feature
   ;; query-params & form-params
   parameters/parameters-middleware
   ;; content-negotiation
   muuntaja/format-negotiate-middleware
   ;; encoding response body
   muuntaja/format-response-middleware
   ;; exception handling
   exception/exception-middleware
   ;; decoding request body
   muuntaja/format-request-middleware
   ;; multipart
   multipart/multipart-middleware
   rrc/coerce-exceptions-middleware
   rrc/coerce-request-middleware
   rrc/coerce-response-middleware])

;; The following middleware setup has been copied as is from electric-starter-app.server-jetty
(defn not-found-handler [_ring-request]
  (-> (res/not-found "Not found")
      (res/content-type "text/plain")))

(defn template
  "In string template `<div>$:foo/bar$</div>`, replace all instances of $key$
with target specified by map `m`. Target values are coerced to string with `str`.
  E.g. (template \"<div>$:foo$</div>\" {:foo 1}) => \"<div>1</div>\" - 1 is coerced to string."
  [t m] (reduce-kv (fn [acc k v] (str/replace acc (str "$" k "$") (str v))) t m))

(defn electric-websocket-middleware
  "Open a websocket and boot an Electric server program defined by `entrypoint`.
  Takes:
  - a ring handler `next-handler` to call if the request is not a websocket upgrade (e.g. the next middleware in the chain),
  - a `config` map eventually containing {:hyperfiddle.electric/user-version <version>} to ensure client and server share the same version,
    - see `hyperfiddle.electric-ring-adapter/wrap-reject-stale-client`
  - an Electric `entrypoint`: a function (fn [ring-request] (e/boot-server {} my-ns/My-e-defn ring-request))
  "
  [next-handler config entrypoint]
  ;; Applied bottom-up
  (-> (electric-ring/wrap-electric-websocket next-handler entrypoint)
      (cookies/wrap-cookies)
      (electric-ring/wrap-reject-stale-client config)
      (wrap-params)))

(defn get-modules [manifest-path]
  (when-let [manifest (io/resource manifest-path)]
    (let [manifest-folder (when-let [folder-name (second (rseq (str/split manifest-path #"\/")))]
                            (str "/" folder-name "/"))]
      (->> (slurp manifest)
           (edn/read-string)
           (reduce (fn [r module] (assoc r (keyword "hyperfiddle.client.module" (name (:name module)))
                                           (str manifest-folder (:output-name module)))) {})))))

(defn wrap-index-page
  "Server the `index.html` file with injected javascript modules from `manifest.edn`.
`manifest.edn` is generated by the client build and contains javascript modules
information."
  [next-handler {:keys [resources-path manifest-path] :as config}]
  (fn [ring-req]
    (if-let [response (res/resource-response (str (check string? resources-path) "/index.html"))]
      (if-let [bag (merge config (get-modules (check string? manifest-path)))]
        (-> (res/response (template (slurp (:body response)) bag)) ; TODO cache in prod mode
            (res/content-type "text/html")                  ; ensure `index.html` is not cached
            (res/header "Cache-Control" "no-store")
            (res/header "Last-Modified" (get-in response [:headers "Last-Modified"])))
        (-> (res/not-found (pr-str ::missing-shadow-build-manifest)) ; can't inject js modules
            (res/content-type "text/plain")))
      ;; index.html file not found on classpath
      (next-handler ring-req))))

(defn http-middleware [config]
  ;; these compose as functions, so are applied bottom up
  (-> not-found-handler
      (wrap-index-page config)
      (wrap-resource (:resources-path config))))

(defn middleware [config entrypoint]
  (-> (http-middleware config)                              ; 2. otherwise, serve regular http content
      (electric-websocket-middleware config entrypoint)))

(defn default-route-setup [routes {:keys [jetty]} entrypoint]
  (let [{:keys [resources-path]} jetty
        entrypoint (fn [ring-req] (e/boot-server {} entrypoint ring-req))]
    (->> routes
         (into [["/app" {:get {:handler (middleware jetty entrypoint)}}]
                ["/js/*" (ring/create-resource-handler
                           {:root              (str resources-path "/js")
                            :not-found-handler (constantly http/not-found)})]
                ["/public/*" (ring/create-resource-handler
                               {:root              resources-path
                                :not-found-handler (constantly http/not-found)})]
                ["/api"
                 routes
                 ["/ping" {:get {:handler   (constantly (http/ok "pong"))
                                 :summary   "Endpoint to ping server"
                                 :responses {200 {:body [:enum "pong"]}}}}]
                 ["/docs/*"
                  {:get (swagger-ui/create-swagger-ui-handler
                          {:url    "/api/swagger.json"
                           :config {:validator-url nil}})}]
                 ["/swagger.json"
                  {:get {:no-doc  true
                         :swagger {:info {:title       "API documentation"
                                          :description "swagger.json for API"}}
                         :handler (swagger/create-swagger-handler)}}]]]))))